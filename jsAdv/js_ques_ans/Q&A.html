<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ques_Ans</title>
</head>
<body>
    <script>
// 1.
//  function sayHi() {
//   console.log(name); //variable gets hoisted (memory space is set up during the creation phase) with the default value of undefined
//   console.log(age);
//   var name = "Lydia";
//   let age = 21; // This is called the "temporal dead zone". When we try to access the variables before they are declared, JavaScript throws a ReferenceError.

// }

// sayHi(); //undefined and ReferenceError(ans)

// 2.
// for (var i = 0; i < 3; i++) {
//   setTimeout(() => console.log(i), 1);
// }

// for (let i = 0; i < 3; i++) {
//   setTimeout(() => console.log(i), 1);
// }
//3 3 3 and 0 1 2 (ans)

//3.
// const shape = {
//   radius: 10,
//   diameter() {
//     return this.radius * 2;
//   },
//   perimeter: () => 2 * Math.PI * this.radius
// };

// shape.diameter();
// shape.perimeter();
//20 and NaN(ans)
// With arrow functions, the this keyword refers to its current surrounding scope, unlike regular functions! This means that when we call perimeter, it doesn't refer to the shape object, but to its surrounding scope (window for example).
// There is no value radius on that object, which returns NaN.

//4.
// +true;
// !'Lydia';
//1 and false(ans)
//The unary plus tries to convert an operand to a number. true is 1, and false is 0.
// The string 'Lydia' is a truthy value. What we're actually asking, is "is this truthy value falsy?". This returns false.

//5.
// const bird = {
//   size: 'small',
// };

// const mouse = {
//   name: 'Mickey',
//   small: true,
// };

// console.log(mouse[bird["size"]]); // true

//6.
// let c = { greeting: 'Hey!' };
// let d;

// d = c;
// c.greeting = 'Hello';
// console.log(d.greeting);
//hello (ans)

//7.
// let a = 3;
// let b = new Number(3);
// let c = 3;

// console.log(a == b);
// console.log(a === b);
// console.log(b === c);

//true false false (ans)

//8.
// class Chameleon {
//   static colorChange(newColor) {
//     this.newColor = newColor;
//     return this.newColor;
//   }

//   constructor({ newColor = 'green' } = {}) {
//     this.newColor = newColor;
//   }
// }

// const freddie = new Chameleon({ newColor: 'purple' });
// console.log(freddie.colorChange('orange'));
//TypeError
//The colorChange function is static. Static methods are designed to live only on the constructor in which they are created, and cannot be passed down to any children or called upon class instances. Since freddie is an instance of class Chameleon, the function cannot be called upon it. A TypeError is thrown.

//8.
// let greeting;
// greetign = {}; // Typo!
// console.log(greetign);
//blank object {} (ans)

//9.What happens when we do this?
// function bark() {
//   console.log('Woof!');
// }

// bark.animal = 'dog';
// Nothing, this is totally fine!
//This is possible in JavaScript, because functions are objects! (Everything besides primitive types are objects)
// A function is a special type of object. The code you write yourself isn't the actual function. The function is an object with properties. This property is invocable.

//10.
// function Person(firstName, lastName) {
//   this.firstName = firstName;
//   this.lastName = lastName;
// }

// const member = new Person('Lydia', 'Hallie');
// Person.getFullName = function() {
//   return `${this.firstName} ${this.lastName}`;
// };
// //correct
// // Person.prototype.getFullName = function() {
// //   return `${this.firstName} ${this.lastName}`;
// // };

// console.log(member.getFullName());

//typeerror(ans)
//If you want a method to be available to all object instances, you have to add it to the prototype property:


//11.
// function Person(firstName, lastName) {
//   this.firstName = firstName;
//   this.lastName = lastName;
// }

// const lydia = new Person('Lydia', 'Hallie');
// const sarah = Person('Sarah', 'Smith');

// console.log(lydia);
// console.log(sarah);
// A: Person {firstName: "Lydia", lastName: "Hallie"} and undefined (ans)

//For sarah, we didn't use the new keyword. When using new, this refers to the new empty object we create. However, if you don't add new, this refers to the global object!


//// 12. What are the three phases of event propagation?
// Capturing > Target > Bubbling(ans)


//13.
// All objects have prototypes, except for the base object. The base object is the object created by the user, or an object that is created using the new keyword. The base object has access to some methods and properties, such as .toString. This is the reason why you can use built-in JavaScript methods! All of such methods are available on the prototype. Although JavaScript can't find it directly on your object, it goes down the prototype chain and finds it there, which makes it accessible for you.


//14.
// function sum(a, b) {
//   return a + b;
// }

// sum(1, '2');
// "12" (ans) 
// JavaScript is a dynamically typed language: we don't specify what types certain variables are. Values can automatically be converted into another type without you knowing, which is called implicit type coercion. Coercion is converting from one type into another.


//15.
// function getPersonInfo(one, two, three) {
//   console.log(one);
//   console.log(two);
//   console.log(three);
// }

// const person = 'Lydia';
// const age = 21;

// getPersonInfo`${person} is ${age} years old`;
//["", " is ", " years old"] "Lydia" 21 (ans)

//If you use tagged template literals, the value of the first argument is always an array of the string values. The remaining arguments get the values of the passed expressions!

const sum = eval("10*10+5");
console.log(sum);





    </script>
</body>
</html>